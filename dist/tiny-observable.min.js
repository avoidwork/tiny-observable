/*!
 2023 Jason Mulligan <jason.mulligan@avoidwork.com>
 @version 2.0.2
*/
const e=()=>{},t="Invalid arguments";class r{constructor(e=10){this.limit=e,this.listeners=new Map,this.hooks=new WeakMap}addListener(t="",r=e,s=this.id(),i=this){return this.on(t,r,s,i)}dispatch(e="",...r){if(0===e.length)throw new TypeError(t);return this.listeners.get(e)?.forEach((e=>e.handler.apply(e.scope,r))),this}emit(e="",...t){return this.dispatch(e,...t)}eventNames(){return Array.from(this.listeners.keys())}getMaxListeners(){return this.limit}hook(e=null,r=""){if(null===e||0===r.length)throw new TypeError(t);for(const t of Array.isArray(e)?e:[e])!1===this.hooks.has(t)&&this.hooks.set(t,new Map),!1===this.hooks.get(t).has(r)&&this.hooks.get(t).set(r,(e=>this.dispatch(r,e))),t?.addEventListener(r,this.hooks.get(t).get(r),!1);return this}id(){return`observable-${Math.random().toString(36).slice(2,9)}`}listenerCount(e=""){if(0===e.length)throw new TypeError(t);return this.listeners.get(e)?.size??0}off(e="",r=""){if(0===e.length)throw new TypeError(t);return 0===r.length?this.listeners.get(e)?.clear():r.length>0&&this.listeners.get(e)?.delete(r),this}on(r="",s=e,i=this.id(),h=this){if(0===r.length)throw new TypeError(t);if(!1===this.listeners.has(r)&&this.listeners.set(r,new Map),this.listeners.get(r).size>=this.limit)throw new Error("`Possible memory leak, more than {{LIMIT}} listeners for event: {{EVENT}}".replace("{{EVENT}}",r).replace("{{LIMIT}}",this.limit));return this.listeners.get(r).set(i,{scope:h,handler:s}),this}once(t="",r=e,s=this.id(),i=this){return this.on(t,((...e)=>{r.apply(i,e),this.off(t,s)}),s,i)}rawListeners(e=""){if(0===e.length)throw new TypeError(t);return Array.from(this.listeners.get(e)?.values()??[]).map((e=>e.handler))}removeAllListeners(e=""){return this.off(e)}removeListener(e="",t=""){return this.off(e,t)}setMaxListeners(e=10){if(isNaN(e))throw new TypeError(t);return this.limit=e,this}unhook(e=null,r=""){if(null===e)throw new TypeError(t);for(const t of Array.isArray(e)?e:[e])this.hooks.has(t)&&(r.length>0&&this.hooks.get(t).has(r)?(t?.removeEventListener(r,this.hooks.get(t).get(r),!1),this.hooks.get(t)?.delete(r)):(this.hooks.get(t).forEach(((e,r)=>t?.removeEventListener(r,e,!1))),this.hooks.delete(t)));return this}}function s(e=10){return new r(e)}export{r as Observable,s as observable};//# sourceMappingURL=tiny-observable.min.js.map
