/*!
 2023 Jason Mulligan <jason.mulligan@avoidwork.com>
 @version 2.0.0
*/
const e=()=>{},t=()=>`ob-${Math.random().toString(36).slice(2,9)}`,r="Invalid arguments";class s{constructor(e=10,r=crypto?.randomUUID??t){this.id=r,this.limit=e,this.listeners=new Map,this.hooks=new WeakMap}addListener(t="",r=e,s=this.id(),i=this){return this.on(t,r,s,i)}dispatch(e="",...t){if(0===e.length)throw new TypeError(r);return this.listeners.get(e)?.forEach((e=>e.handler.apply(e.scope,t))),this}emit(e="",...t){return this.dispatch(e,...t)}eventNames(){return Array.from(this.listeners.keys())}getMaxListeners(){return this.limit}listenerCount(e=""){if(0===e.length)throw new TypeError(r);return this.listeners.get(e)?.size??0}hook(e=null,t=""){if(null===e||0===t.length)throw new TypeError(r);for(const r of Array.isArray(e)?e:[e])!1===this.hooks.has(r)&&this.hooks.set(r,new Map),!1===this.hooks.get(r).has(t)&&this.hooks.get(r).set(t,(e=>this.dispatch(t,e))),r?.addEventListener(t,this.hooks.get(r).get(t),!1);return this}off(e="",t=""){if(0===e.length)throw new TypeError(r);return 0===t.length?this.listeners.get(e)?.clear():t.length>0&&this.listeners.get(e)?.delete(t),this}on(t="",s=e,i=this.id(),h=this){if(0===t.length)throw new TypeError(r);if(!1===this.listeners.has(t)&&this.listeners.set(t,new Map),this.listeners.get(t).size>=this.limit)throw new Error("`Possible memory leak, more than {{LIMIT}} listeners for event: {{EVENT}}".replace("{{EVENT}}",t).replace("{{LIMIT}}",this.limit));return this.listeners.get(t).set(i,{scope:h,handler:s}),this}once(t="",r=e,s=this.id(),i=this){return this.on(t,((...e)=>{r.apply(i,e),this.off(t,s)}),s,i)}rawListeners(e=""){if(0===e.length)throw new TypeError(r);return Array.from(this.listeners.get(e)?.values()??[])}removeAllListeners(e=""){return this.off(e)}removeListener(e="",t=""){return this.off(e,t)}setMaxListeners(e=10){if(isNaN(e))throw new TypeError(r);return this.limit=e,this}unhook(e=null,t=""){if(null===e)throw new TypeError(r);for(const r of Array.isArray(e)?e:[e])this.hooks.has(r)&&(t.length>0&&this.hooks.get(r).has(t)?(r?.removeEventListener(t,this.hooks.get(r).get(t),!1),this.hooks.get(r)?.delete(t)):(this.hooks.get(r).forEach(((e,t)=>r?.removeEventListener(t,e,!1))),this.hooks.delete(r)));return this}}function i(e=10,r=crypto?.randomUUID??t){return new s(e,r)}export{s as Observable,i as observable};//# sourceMappingURL=tiny-observable.min.js.map
