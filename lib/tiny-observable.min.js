/* 2015 Jason Mulligan <jason.mulligan@avoidwork.com> */

"use strict";function _classCallCheck(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}var _createClass=function(){function a(a,b){for(var c=0;c<b.length;c++){var d=b[c];d.enumerable=d.enumerable||!1,d.configurable=!0,"value"in d&&(d.writable=!0),Object.defineProperty(a,d.key,d)}}return function(b,c,d){return c&&a(b.prototype,c),d&&a(b,d),b}}();!function(a){function b(a,b){return void 0!==a[b]}function c(a,b){var c=arguments.length<=2||void 0===arguments[2]?a:arguments[2];return function(){Object.keys(a).forEach(function(a,d){b.call(c,a,d)})}()}function d(){return(65536*(1+Math.random())|0).toString(16).substring(1)}function e(){return d()+d()+"-"+d()+"-4"+d().substr(0,3)+"-"+g[Math.floor(4*Math.random())]+d().substr(0,3)+"-"+d()+d()+d()}function f(a){return new Observable(a)}var WeakMap=a.WeakMap||require("es6-weak-map"),g=[8,9,"a","b"],Observable=function(){function Observable(){var a=arguments.length<=0||void 0===arguments[0]?10:arguments[0];_classCallCheck(this,Observable),this.limit=a,this.listeners={},this.hooks=new WeakMap}return _createClass(Observable,[{key:"dispatch",value:function(a){for(var d=arguments.length,e=Array(d>1?d-1:0),f=1;d>f;f++)e[f-1]=arguments[f];return a&&b(this.listeners,a)&&c(this.listeners[a],function(a){a.handler.apply(a.scope,e)}),this}},{key:"hook",value:function(a,c){var d=this,e=void 0;if(!b(a,addEventListener))throw new Error("Invalid Arguments");return e=this.hooks.get(a)||{},b(e,c)||(e[c]=function(a){d.dispatch(c,a)}),this.hooks.set(a,e),a.addEventListener(c,this.hooks.get(a)[c],!1),a}},{key:"off",value:function(a,c){return b(this.listeners,a)&&(c?delete this.listeners[a][c]:delete this.listeners[a]),this}},{key:"on",value:function(a,c){var d=arguments.length<=2||void 0===arguments[2]?e():arguments[2],f=arguments.length<=3||void 0===arguments[3]?void 0:arguments[3];if(b(this.listeners,a)||(this.listeners[a]={}),Object.keys(this.listeners[a]).length>=this.limit)throw new Error("Possible memory leak, more than "+this.limit+" listeners for event: "+a);return this.listeners[a][d]={scope:f||this,handler:c},this}},{key:"once",value:function(a,b){var c=this,d=arguments.length<=2||void 0===arguments[2]?e():arguments[2],f=arguments.length<=3||void 0===arguments[3]?void 0:arguments[3],g=f||this;return this.on(a,function(){for(var e=arguments.length,f=Array(e),h=0;e>h;h++)f[h]=arguments[h];b.apply(g,f),c.off(a,d)},d,g)}},{key:"unhook",value:function(a,b){var c=this.hooks.get(a);return c&&(a.removeEventListener(b,c[b],!1),delete c[b],0===Object.keys(c).length?this.hooks["delete"](a):this.hooks.set(a,c)),a}}]),Observable}();f.version="1.0.0","undefined"!=typeof exports?module.exports=f:"function"==typeof define?define(function(){return f}):a.observable=f}("undefined"!=typeof window?window:global);
//# sourceMappingURL=tiny-observable.min.js.map